# Binary Search Trees

Start a new BlueJ project named **hw280-bst** and copy the [BST.java](../code/BST.java) code file into it.

---

# Task 1 - Binary Search Tree Iterator

Implement an iterator over the binary search tree (BST) code provided in class. Your iterator should be initialized with the root node of the BST. Calling next() should return the next smallest key in the BST.

If you need to review the concept of iterators, here's a recording of the lecture on iterators:

- [Lecture recording](https://berry.zoom.us/rec/share/RmgLuCNHDSxym971lmnLmZ4fmXn5RLhzwasJ9Q6ujjUrokZQ8EjZ9XVqkGWE1v8I.x_2TlcGFLDxGRq5d?startTime=1603457987000)
 
- [Code from lecture is here](../../lec270-iterator/in-class/)


## Approach

- Make the `BST` class implement `Iterable<Key>`.
- Add an `iterator()` method to the `BST` class which will return an iterator object. You will need to define a new class that implements `Iterator<Key>` in order to construct and return an object of it. Name your class `InorderIterator`.
- Your iterator object will need to go systematically through all the nodes in the tree, but in "slow motion" - i.e. only returning one at a time from the `next()` method. To keep track of things, your `InorderIterator` will keep track of a stack of `Node`s in the tree, so declare a field for a `Stack<Node>`.
-  To set things up, in the constructor (after initializing an empty stack), push all the left nodes starting from the root. This will push the nodes in descending order.
- In the `hasNext()` return `true` if the stack has elements and `false` if it's empty. (Do not use an `if` statement.)
- In the `next()` method, pop a node from the stack, push to the stack the right subtree of the node (if any), and return the node's value. (What we mean by "the right subtree" is all the left nodes starting from the root of the right subtree.)

You should trace an example of these operations out on paper to see how they work.

Make sure to test your code. (Create a test class, add some elements to a BST, then obtain an iterator object and check the results of `hasNext()` and `next()`.)


## Run Time Complexity (worst case)

- hasNext(): 𝑂(1)
- next(): 𝑂(log𝑛)=𝑂(ℎ)  where h is the height of the tree
- memory used: 𝑂(log𝑛)=𝑂(ℎ) where h is the height of the tree

```
```


---

Task 2 - Lowest Common Ancestor

